#! /usr/bin/env python
# vim: set ft=python ts=4 sw=4 sts=4 et :
# -*- coding: utf-8 -*-

# setup.py --- Qubes Builder Configuration Utiltiy
#
# Copyright (C) 2015  Jason Mehring
#
# License: GPL-2+
# ------------------------------------------------------------------------------
# Install 'dialog' program if it does not yet exist
# ------------------------------------------------------------------------------

from __future__ import unicode_literals

import argparse
import codecs
import collections
import copy
import locale
import os
import re
import shlex
import shutil
import sys
import types

from ConfigParser import ConfigParser
from textwrap import dedent, wrap

# Globals
DIALOG = 'dialog'
GPG_KEY_SERVER = 'pgp.mit.edu'
DEVELOPMENT_MODE = False
SETUP_DEPENDENCIES = ['dialog']

# Global file locations
BASE_DIR              = os.getcwd()
CONFIG_DIR            = 'example-configs'
OVERRIDE_CONF         = 'override.conf'
OVERRIDE_DATA         = 'override.data'
MASTER_TEMPLATE       = 'templates.conf'
BUILDER_CONF          = 'builder.conf'
BACKUP_EXTENSION      =  '.bak'
QUBES_DEVELOPERS_KEYS = 'qubes-developers-keys.asc'
GNUPGHOME = os.path.join(os.path.abspath(BASE_DIR), 'keyrings/git')

# Add 'qubes-builder/libs' directory to sys.path
LIBS_DIR = os.path.join(BASE_DIR, 'libs')
if os.path.exists(LIBS_DIR) and os.path.isdir(LIBS_DIR):
    if LIBS_DIR not in sys.path:
        sys.path.insert(1, LIBS_DIR)

from ansi import ANSIColor

locale.setlocale(locale.LC_ALL, '')


def exit(*varargs, **kwargs):
    '''Function to exit.  Maybe restoring some files before exiting.
    '''
    kwargs['title'] = 'System Exit!'
    kwargs['width'] = 80
    kwargs['height'] = 0  # Auto height

    try:
        DefaultUI.ui.infobox(*varargs, **kwargs)
    except AttributeError:
        pass

    # Restore original template.conf
    try:
        config = Config(None)
        if os.path.exists(config.conf_builder + BACKUP_EXTENSION):
            shutil.move(config.conf_builder + BACKUP_EXTENSION, config.conf_builder)
    except NameError:
        pass

    sys.exit()


def getchar():
    try:
        import termios
    except ImportError:
        import msvcrt
        return msvcrt.getchar()

    import sys, tty
    def _getchar():
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            char = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return char
    return _getchar()


def install_deps(depends_label):
    if not depends_label:
        return

    import os
    import subprocess
    import time

    from subprocess import (Popen, STDOUT)
    try:
        from subprocess import DEVNULL # py3k
    except ImportError:
        import os
        DEVNULL = open(os.devnull, 'wb')

    ansi = ANSIColor()
    env = os.environ.copy()

    if SETUP_DEPENDENCIES:
        env['DEPENDENCIES'] = ' '.join(SETUP_DEPENDENCIES)
    if not os.path.exists(BUILDER_CONF):
        env['BUILDERCONF'] = MASTER_TEMPLATE

    try:
        print 'exec'
        env['GET_VAR'] = 'DEPENDENCIES'
        build_depends = subprocess.check_output(['make', '--always-make', '--quiet', 'get-var'], env=env).strip()
        env.pop('GET_VAR')
    except (subprocess.CalledProcessError):
        print '\nAn error occured trying to determine dependencies and therefore setup must now exit'
        print 'Exiting!'
        exit()

    os.system('clear')
    message1 = 'The following dependencies may not have been met:\n'
    message2 = '\nThe following {ansi[bold]}build dependencies{ansi[normal]}{ansi[blue]} will be installed:\n'.format(ansi=ansi)
    print '{ansi[blue]}{0}{ansi[red]}{1}{ansi[normal]}\r\r'.format(message1, depends_label, ansi=ansi)
    print '{ansi[blue]}{0}{ansi[red]}{1}{ansi[normal]}\r\r'.format(message2, build_depends, ansi=ansi)
    print '\nEnter \'Y\' to install {ansi[red]}ALL{ansi[normal]} build dependencies now, or anything else to quit [YyNnQq]: '.format(ansi=ansi)
    char =  getchar()
    if char.lower() != 'y':
        print '\nYou selected not to install the dependencies and therefore setup must now exit'.format(ansi=ansi)
        print 'Exiting!'
        exit()

    os.system('clear')
    sys.stdout.write('Waiting for {ansi[red]}{0}{ansi[normal]} to install\n'.format(build_depends, ansi=ansi))
    sys.stdout.flush()

    proc = Popen(['make', 'install-deps'], stdout=DEVNULL, stderr=STDOUT, env=env)
    while proc.poll() is None:
        sys.stdout.write('{ansi[red]}.{ansi[normal]}'.format(ansi=ansi))
        sys.stdout.flush()
        time.sleep(1)
    print

    if proc.returncode:
        print '\nThere was an error installing dependencies!{ansi[blue]}{ansi[normal]} and therefore setup must now exit'.format(ansi=ansi)
        print 'Exiting!'
        exit()


def write_file(filename, text):
    try:
        with codecs.open(filename, 'w', 'utf8') as outfile:
            outfile.write(dedent(text))
    except IOError, err:
        exit(err)


def parse_parentheses(text):
    '''A very simple lexer to parse round parentheses.
    '''
    ansi = ANSIColor()

    lexer = shlex.shlex(text)
    lexer.whitespace = '\t\r\n'

    text = ''
    raw = ''
    count =  0

    for token in lexer:
        chars = token
        if  chars[0] in '\'"' and chars[-1] in '\'"':
            new_chars = parse_parentheses(chars[1:-1])
            text += chars[0] + new_chars + chars[-1]
            continue
        if token == '(':
            count += 1
            if raw and raw[-1] == '$':
                chars = '{ansi[blue]}{0}'.format(chars, ansi=ansi)
        elif token == ')':
            if count == 1:
                chars = '{0}{ansi[normal]}'.format(chars, ansi=ansi)
            count -= 1
        elif count:
            if raw and raw[-1] != '(':
                chars = '{ansi[black]}{0}'.format(chars, ansi=ansi)

        raw += token
        text += chars

    return text


def display_configuration(filename):
    '''Display the configuration file.
    '''
    ansi = ANSIColor()
    print '{ansi[bold]}{ansi[black]}{0}:{ansi[normal]}'.format(filename, ansi=ansi)
    try:
        with codecs.open(filename, 'r', 'utf8') as infile:
            for line in infile:
                match = re.match(r'(?P<text>.*?(?=#)|.*)(?P<comment>([#]+.*)|)', line.rstrip())
                if match:
                    line = ''
                    text = match.groupdict()['text']
                    comment = match.groupdict()['comment']
                    if match.groupdict()['text']:
                        var = re.match(r'(?P<var>.*)(?P<text>[?:]?=.*)', text)
                        target = re.match(r'(?P<target>.*[:]+)(?P<text>.*)', text)
                        text = parse_parentheses(text)

                        if var:
                            line += '{ansi[blue]}{d[var]}{ansi[normal]}{d[text]}'.format(d=var.groupdict(), ansi=ansi)
                        elif target:
                            line += '{ansi[red]}{d[target]}{ansi[normal]}{d[text]}'.format(d=target.groupdict(), ansi=ansi)
                        else:
                            line += '{ansi[black]}{0}{ansi[normal]}'.format(text, ansi=ansi)

                    if comment:
                        line += '{ansi[green]}{0}{ansi[normal]}'.format(comment, ansi=ansi)
                print line
    except IOError, err:
        exit(err)


def soft_link(source, target):
    '''Attempt to soft-link a file.  Exit with message on failure.
    '''
    try:
        if os.path.exists(target) and not os.path.islink(target):
            message = 'Setup will not over-write regular files that are not soft-linked.'
            exit('Error linking:\n{0} to {1}\n\n{2}'.format(source, target, message))

        if os.path.exists(source):
            if os.path.exists(target):
                os.remove(target)
            os.symlink(source, target)
        else:
            message = 'Target file does not exist and therefore cannot be linked.'
            exit('Error linking:\n{0} to {1}\n\n{2}'.format(source, target, message))
    except OSError, e:
        exit('Error linking:\n{0} to {1}\n\n{2}.'.format(source, target, e.strerror))


class DefaultUI(object):
    '''Default UI contains pointer to selected UI.
    '''
    ui = None

    @classmethod
    def __init__(cls, ui):
        cls.ui = ui


class DialogUI(DefaultUI):
    '''UI Interface to `dialog` API.
    '''
    from dialog import (Dialog, ExecutableNotFound)

    try:
        from textwrap import indent
    except ImportError:
        @staticmethod
        def indent(text, prefix, predicate=None):
            l = []
            for line in text.splitlines(True):
                if (callable(predicate) and predicate(line)) \
                   or (not callable(predicate) and predicate) \
                   or (predicate is None and line.strip()):
                    line = prefix + line
                l.append(line)
            return ''.join(l)

    # Initialize a dialog.Dialog instance
    try:
        dialog = Dialog(dialog=DIALOG)
    except (ExecutableNotFound):
        install_deps('dialog')
        dialog = Dialog(dialog=DIALOG)

    @classmethod
    def __init__(cls):
        cls.dialog.set_background_title("Qubes Builder Configuration Utility")
        super(DialogUI, cls).__init__(cls)

    @classmethod
    def _auto_height(cls, width, text):
        _max = max(8, 5 + len(wrap(text, width=width)))  # Min of 8 rows
        _min = min(22, _max)  # Max of 22 rows
        return _min

    @classmethod
    def yesno(cls, **info):
        '''YesNo dialog.
        '''
        default = {
            'colors': True,
            'width': 60,
            'height': 8,
        }

        default.update(info)
        code = cls.dialog.yesno(**default)

        if code == cls.dialog.OK:
            return True
        elif code == cls.dialog.CANCEL:
            return False
        elif code == cls.dialog.ESC:
            exit('Escape key pressed. Exiting.')

    @classmethod
    def msgbox(cls, *varargs, **info):
        '''Msgbox dialog.

        Only displays if text is provided. Text can be provided in varargs
        '''
        default = {
            'colors': True,
            'title':  'Qubes Setup Information.',
            'width': 72,
            'height': 8,
            'text': ''
        }

        default.update(info)
        if varargs:
            default['text'] = ' '.join(varargs)

        if not default['height']:
            default['height'] = cls._auto_height(default['width'], default['text'])

        if default['text']:
            cls.dialog.msgbox(**default)

    @classmethod
    def infobox(cls, *varargs, **info):
        '''Infobox dialog.

        Only displays if text is provided. Text can be provided in varargs
        '''
        default = {
            'colors': True,
            'title':  'Qubes Setup Information.',
            'width': 72,
            'height': 8,
            'text': ''
        }

        default.update(info)
        if varargs:
            default['text'] = ' '.join(varargs)

        if not default['height']:
            default['height'] = cls._auto_height(default['width'], default['text'])

        if default['text']:
            cls.dialog.infobox(**default)

    @classmethod
    def list_done(cls, code, tag, helper=None):
        if not helper:
            helper = {}
        no_help = "You asked for help about something called '{0}'. Sorry, but I am quite incompetent in this matter."

        if code == 'help':
            tag, selected_tags, choices = tag
            cls.msgbox(helper.get(tag, no_help.format(tag)), height=0, width=60)
            return False

        elif code == cls.dialog.CANCEL:
            exit('User aborted setup.')

        elif code == cls.dialog.ESC:
            exit('User aborted setup.')

        else:
            return True

    @classmethod
    def checklist(cls, **info):
        '''Checklist dialog.
        '''
        default = {
            'colors': True,
            'height': 0,
            'width': 0,
            'list_height': 0,
            'choices': [],
            'title': '',
            'help_button': False,
            'item_help': False,
            'help_tags': False,
            'help_status': False,
            'text': '',
        }
        default.update(info)
        helper = default.pop('helper', {})

        while True:
            code, tag = cls.dialog.checklist(**default)
            if cls.list_done(code, tag, helper):
                break

        string = '\n'.join(tag)
        return tag

    @classmethod
    def radiolist(cls, **info):
        '''Radiolist dialog.
        '''
        default = {
            'colors': True,
            'height': 0,
            'width': 0,
            'list_height': 0,
            'choices': [],
            'title': '',
            'help_button': False,
            'item_help': False,
            'help_tags': False,
            'help_status': False,
            'text': '',
        }
        default.update(info)
        helper = default.pop('helper', {})

        while True:
            code, tag = cls.dialog.radiolist(**default)
            if cls.list_done(code, tag, helper):
                break

        return tag

    @classmethod
    def release(cls, **info):
        '''Display `select release` dialog of Qubes release version to build.
        '''
        return cls.yesno(**info)

    @classmethod
    def override(cls, **info):
        '''Display use override confirmation.
        '''
        return cls.yesno(**info)

    @classmethod
    def repo(cls, **info):
        '''Display `choose repo` dialog.
        '''
        return cls.radiolist(**info)

    @classmethod
    def ssh_access(cls, **info):
        '''Display ssh-access dialog.
        '''
        return cls.yesno(**info)

    @classmethod
    def template_only(cls, **info):
        '''Display dialog choice of building only templates.
        '''
        return cls.yesno(**info)

    @classmethod
    def dists(cls, **info):
        '''Display DISTS_VM's for selction.
        '''
        return cls.checklist(**info)

    @classmethod
    def builders(cls, **info):
        '''Display BUILDER_PLUGINS's for selction.
        '''
        return cls.checklist(**info)

    @classmethod
    def verify_keys(cls, **info):
        '''Display `verify keys` confirmation dialog.
        '''
        default = {
            'height': 12,
        }
        default.update(info)
        return cls.yesno(**default)

    @classmethod
    def get_sources(cls, **info):
        '''Display get-sources dialog.
        '''
        result = cls.yesno(**info)
        get_sources = 1 if result else 0

        # Download sources
        if get_sources:
            import subprocess
            try:
                from subprocess import DEVNULL # py3k
            except ImportError:
                DEVNULL = open(os.devnull, 'wb')

            env = os.environ.copy()
            env['bold'] = ''
            env['normal'] = ''
            env['black'] = ''
            env['red'] = ''
            env['green'] = ''
            env['blue'] = ''
            env['white'] = ''

            args = ['make', 'get-sources']
            p = subprocess.Popen(args, stdout=subprocess.PIPE,
                stderr=DEVNULL, close_fds=True, env=env)

            default = {
                #'colors': True,
                #'scrollbar': True,
                'height': 40,
                'width': 120,
            }

            cls.dialog.programbox(fd=p.stdout.fileno(),
                text="Get sources", **default)
            retcode = p.wait()

            # Context manager support for subprocess.Popen objects requires
            # Python 3.2 or later.
            p.stdout.close()
            return retcode


class Config(object):
    '''Configuration objects holds all config data.

    Provides provides methods to read and write the data
    '''
    MARKER = object()

    _makefile_vars = {
        'about':                     '',
        'release':                   0 ,
        'ssh_access':                0 ,
        'template_only':             0 ,
        'override_source':           '',
        'git_baseurl':               '',
        'git_prefix':                '',
        'git_prefix_default':        '',
        'dist_dom0_selected':        '',
        'dists_vm_all':              [],
        'dists_vm_selected':         [],
        'builders_selected':         [],
        'template_aliases_reversed': [],
        'template_labels':           [],
        'template_labels_reversed':  [],
    }

    _defaults_builder = {
        'id'          : '',
        'type'        : '',
        'description' : '',
        'optional'    : [],
        'require'     : [],
        'require_in'  : [],
        'development' : False,
    }

    _defaults_key = {
        'id'          : '',
        'type'        : '',
        'key'         : '',
        'owner'       : '',
        'fingerprint' : None,
        'verify'      : '',
        'url'         : '',
    }

    _defaults_repo = {
        'type'        : '',
        'description' : '',
        'prefix'      : '',
    }

    def __init__(self, filename, **options):
        '''Init.

        filename is the name of the main configuration file to load which
        is typically .salt.conf and is configurable with commandline option
        '-c'
        '''
        self.filename = filename
        self.options = options

        self.dir_builder = self.options.get('dir_builder') or os.path.abspath(os.path.curdir)
        self.dir_configurations = os.path.join(self.dir_builder, CONFIG_DIR)

        # Override configuration filename will override and merge into .setup.data
        self.conf_override_data = os.path.join(self.dir_builder, OVERRIDE_DATA)

        self.parser = ConfigParser()
        self.parser.add_section('makefile')
        self.sections = []
        self.keys = collections.OrderedDict()
        self.repos = collections.OrderedDict()
        self.builders = collections.OrderedDict()

        self._init_makefile_vars()

        self.conf_template = os.path.join(self.dir_configurations, MASTER_TEMPLATE)
        self.conf_override = os.path.join(self.dir_builder, OVERRIDE_CONF)
        self.conf_builder = os.path.join(self.dir_builder, BUILDER_CONF)

        # Copy example-configs/template.conf to builder.conf if
        # the configuration file does not yet exist
        self._create_builder_conf(force=False)

        # Set up any branch specific override configurations
        self._overrides()

        # Parse Makefiles
        self._parse_makefiles()

        # Load .setup.data
        if filename and os.path.exists(filename):
            self._load()
            if os.path.exists(self.conf_override_data):
                self._load(self.conf_override_data)

    def _init_makefile_vars(self):
        for key, value in self._makefile_vars.items():
            setattr(self, key, value)

    def _create_builder_conf(self, force=False):
        '''Copies example-configs/template.conf to builder.conf
        '''
        if not os.path.exists(self.conf_builder) or force:
            try:
                if os.path.exists(self.conf_builder) and force:
                    os.remove(self.conf_builder)

                shutil.copy2(self.conf_template, self.conf_builder)

                # ABOUT
                replace = ReplaceInplace(self.conf_builder)
                replace.add(**{
                    'replace': r'@echo "{0}"'.format(MASTER_TEMPLATE),
                    'text': r'@echo "{0}"'.format(BUILDER_CONF),
                })
                replace.start()
            except IOError, err:
                exit(err)

    #def __getattribute__(self, name):
    #    return super(Config, self).__getattribute__(name)

    def _coerce_value(self, default, value):
        if type(value) != type(default):
            try:
                if isinstance(default, types.BooleanType):
                    value = bool(value)
                elif isinstance(default, types.IntType):
                    value = int(value)
                elif isinstance(default, types.FloatType):
                    value = float(value)
                elif isinstance(default, types.ListType):
                    if isinstance(value, types.StringTypes):
                        if value.strip().lower() in ['none', 'null']:
                            value = []
                        else:
                            value = value.strip().split()
                elif isinstance(default, types.NoneType):
                    value = None
            except ValueError:
                value = default
        return value

    def _coerce_values(self, defaults, values):
        if not isinstance(defaults, collections.Mapping):
            return values
        if isinstance(values, collections.Mapping):
            for key, value in values.items():
                if key in defaults:
                    values[key] = self._coerce_value(defaults[key], value)
        return values

    def __setattr__(self, name, value):
        if name in self._makefile_vars:
            default = self._makefile_vars[name]
            value = self._coerce_value(default, value)
            self.parser.set('makefile', name, value)
        return super(Config, self).__setattr__(name, value)

    def _get_section(self, section_name):
        adict = {}
        options = self.parser.options(section_name)
        for option in options:
            try:
                adict[option] = self.parser.get(section_name, option)
                #if adict[option] == -1:
                #    adict.pop(option, None)
            except:
                adict[option] = None
        return adict

    def _load(self, filename=None):
        if not filename:
            filename = self.filename

        self.parser.readfp(codecs.open(filename, 'r', 'utf8'))
        for section_name in self.parser.sections():
            section = self._get_section(section_name)
            if not section:
                continue
            section_type = section.get('type')
            if section_type == 'gpg':
                config = copy.deepcopy(self._defaults_key)
                section['id'] = section_name
                config.update(section)
                self.keys[section_name] = config
            elif section_type == 'repo':
                config = copy.deepcopy(self._defaults_repo)
                config.update(section)
                self.repos[section_name] = config
            elif section_type == 'builder':
                config = copy.deepcopy(self._defaults_builder)
                config.update(section)
                self.builders[section_name] = self._coerce_values(self._defaults_builder, config)

    def _overrides(self):
        '''Set up any branch specific override configurations.
        '''
        #--------------------------------------------------------------------------
        # See if a branch specific override configuration file exists
        #--------------------------------------------------------------------------
        branch = sh.git('rev-parse', '--abbrev-ref', 'HEAD').strip()
        override_target = self.conf_override
        override_source = None

        # Skip if overrides already exsits and is a regular file
        if not (os.path.exists(self.conf_override) and not os.path.islink(self.conf_override)):
            dir = self.dir_configurations
            override = os.path.basename(self.conf_override)

            patterns = []
            # Example: example-configs/r3-feature_branch-override.conf
            patterns.append('{0}/r{1}-{2}-{3}'.format(dir, self.release, branch, override))

            # Example: example-configs/feature_branch-override.conf
            patterns.append('{0}/{1}-{2}'.format(dir, branch, override))

            # Example: example-configs/override.conf
            patterns.append('{0}/{1}'.format(dir, override))

            for pattern in patterns:
                if os.path.exists(pattern):
                    override_source = pattern
                    break

            if override_source:
                # If override_target alreaady exists (it is a link or we would not be here)
                # display a confirmation dialog to link if not currently linked to override_source
                if not os.readlink(override_target) == override_source:
                    info = {
                        'title': 'Use Branch Specific Override Configuration File?',
                        'default_button': 'yes',
                        'text': dedent('''\
                        A branch specific configuration file was found in your personal directory:
                        {0}.

                        Would you like to use and override the other provided repos?
                        '''.format(override_source)),
                    }
                    result = DefaultUI.ui.override(**info)

                    # Soft link override_source to override_target if user confirmed override
                    if result:
                        soft_link(override_source, override_target)
                    else:
                        override_source = None

        elif os.path.exists(self.conf_override):
            override_source = self.conf_override

        self.override_source = override_source

    def _parse_makefiles(self):
        '''
        '''
        from sh import make
        env = os.environ.copy()
        make = make.bake('--always-make', '--quiet', 'get-var', directory=self.dir_builder, _env=env)

        # Get variables from Makefile
        try:
            env['GET_VAR'] = 'SSH_ACCESS'
            self.ssh_access = make().strip()

            env['GET_VAR'] = 'TEMPLATE_ONLY'
            self.template_only = make().strip()

            env['GET_VAR'] = 'BUILDER_PLUGINS_ALL'
            self.builders_selected = make().strip()

            env['GET_VAR'] = 'GIT_BASEURL'
            self.git_baseurl = make().strip()

            env['GET_VAR'] = 'GIT_PREFIX'
            self.git_prefix = make().strip()
            self.git_prefix_default= self.git_prefix

            env['GET_VAR'] = 'DISTS_VM'
            self.dists_vm_selected = make().strip().split()

            env['GET_VAR'] = 'DIST_DOM0'
            self.dist_dom0_selected = make().strip().split()

            env['SETUP_MODE'] = '1'
            env['GET_VAR'] = 'DISTS_VM'
            self.dists_vm_all = make().strip().split()

            env['GET_VAR'] = 'TEMPLATE_ALIAS'
            aliases = make().strip().split()
            self.template_aliases = dict([(item.split(':')) for item in aliases])
            self.template_aliases_reversed = dict([(value, key) for key, value in self.template_aliases.items()])

            env['GET_VAR'] = 'TEMPLATE_LABEL'
            labels = make().strip().split()
            self.template_labels = dict([(item.split(':')) for item in labels])
            self.template_labels_reversed = dict([(value, key) for key, value in self.template_labels.items()])

            self.about = sh.make('--always-make', '--quiet', 'about', directory=self.dir_builder)
        except sh.ErrorReturnCode, err:
            pass

    def write_configuration(self):
        '''Write builder.conf configuration.
        '''
        replace = ReplaceInplace(self.conf_builder)
        dists_vm = ''
        text = ''

        ### -- INFO -----------------------------------------------------------
        # Format about
        info = '''\
            ################################################################################
            #
            # Qubes Release: {self[release]}
            # Source Prefix: {self[git_prefix]} (repo)
            #
            # Master Configuration File(s):
            # {about}
            #
            # builder.conf copied from:
            # {self[conf_template]}
            #
            ################################################################################
            '''.format(about=' '.join(self.about.split()), self=vars(self))

        ### -- DISTS_VM -------------------------------------------------------
        for dist in self.dists_vm_selected:
            dists_vm += 'DISTS_VM += {0}\n{1}'.format(dist, '              ')
        dists_vm = dists_vm.strip()

        dists = '''\
            ifneq "$(SETUP_MODE)" "1"

              # Enabled DISTS_VMs
              DISTS_VM :=
              {dists_vm}

            endif
            '''.format(dists_vm=dists_vm, self=vars(self))

        ### -- BUILDER_PLUGINS ------------------------------------------------
        plugins = ''
        for plugin in self.builders_selected:
            plugins += 'BUILDER_PLUGINS += {0}\n{1}'.format(plugin, '              ')
        plugins = plugins.strip()

        plugins = '''\

              # Enabled BUILDER_PLUGINS
              BUILDER_PLUGINS :=
              {plugins}
            '''.format(plugins=plugins, self=vars(self))

        # INFO
        replace.add(**{
            'insert_after': r'.*[[]=setup info start=[]]',
            'insert_until': r'.*[[]=setup info stop=[]]',
            'text': dedent(info).rstrip('\n'),
        })

        # DISTS_VM
        replace.add(**{
            'insert_after': r'.*[[]=setup dists start=[]]',
            'insert_until': r'.*[[]=setup dists stop=[]]',
            'text': dedent(dists).rstrip('\n'),
        })

        # BUILDER_PLUGINS
        replace.add(**{
            'insert_after': r'.*[[]=setup plugins start=[]]',
            'insert_until': r'.*[[]=setup plugins stop=[]]',
            'text': dedent(plugins),
        })

        # RELEASE
        replace.add(**{
            'replace': r'RELEASE[ ]*[?:]?=[ ]*[\d]',
            'text': r'RELEASE := {0}'.format(self.release),
        })

        # SSH_ACCESS
        replace.add(**{
            'replace': r'SSH_ACCESS[ ]*[?:]?=[ ]*[\d]',
            'text': r'SSH_ACCESS := {0}'.format(self.ssh_access),
        })

        # GIT_BASEURL
        replace.add(**{
            'replace': r'GIT_BASEURL[ ]*[?:]?=[ ]*.*',
            'text': r'GIT_BASEURL := {0}'.format(self.git_baseurl),
        })

        # GIT_PREFIX
        replace.add(**{
            'replace': r'GIT_PREFIX[ ]*[?:]?=[ ]*.*',
            'text': r'GIT_PREFIX := {0}'.format(self.git_prefix),
        })

        # TEMPLATE_ONLY
        replace.add(**{
            'replace': r'TEMPLATE_ONLY[ ]*[?:]?=[ ]*.*',
            'text': r'TEMPLATE_ONLY ?= {0}'.format(self.template_only),
        })

        # INCLUDE_OVERRIDE_CONF
        if self.override_source:
            override = r'INCLUDE_OVERRIDE_CONF ?= true'
        else:
            override = r'#INCLUDE_OVERRIDE_CONF ?= true'
        replace.add(**{
            'replace': r'^.*INCLUDE_OVERRIDE_CONF[ ]+[?]?[=].*$',
            'text': r'{0}'.format(override),
        })

        # Start the search and replace process on the configuration file
        replace.start()

    def display_configuration(self):
        ansi =  ANSIColor()
        display_configuration(self.conf_builder)
        info = '\nNew configuration file written to: {0}\n'.format(self.conf_builder)

        install_qubes = '''
            Complete Qubes Build Steps
            --------------------------
            make install-deps
            make get-sources
            make qubes
            make iso
            '''

        install_qubes_vm = '''
            Template Only Build Steps
            -------------------------
            make install-deps
            make get-sources
            make qubes-vm
            make template
            '''

        if self.template_only:
            info += dedent(install_qubes_vm)
        else:
            info += dedent(install_qubes)
        print '{ansi[green]}{0}{ansi[normal]}'.format(info, ansi=ansi)


class Wizard(Config):
    ''''''
    def __init__(self, ui, **kwargs):
        self.ui = ui
        DefaultUI.ui = ui
        self.cli_args = kwargs
        super(Wizard, self).__init__(kwargs['config_filename'], **kwargs)

    def __call__(self):
        ## Check / Install Keys
        ## set force value to 'force' to force re-download and verify
        self.verify_keys(self.keys, force=False)

        ## Choose release version
        ## Soft link 'examples/templates.conf' to 'builder.conf'
        self.set_release(force=True)

        ## Prompt for selection of base repo to use for build
        self.set_repo()

        ## Choose if user has git ssh (commit) or http access to private repos
        if os.path.exists(self.conf_override):
            self.set_ssh_access()

        ## Choose to build a complete system or templates only
        self.set_template_only()

        ## Enable builders
        self.set_builders()

        ## Select which templates to build (DISTS_VM)
        self.set_dists()

        ## Write builder.conf
        self.write_configuration()

        ## Display builder.conf
        self.display_configuration()

    def check_gnupghome(self, gnupghome):
        if not os.path.exists(gnupghome):
            os.makedirs(gnupghome, mode=0700)

    def gpg_verify_key(self, key_data):
        verified = False
        env = os.environ.copy()
        env['GNUPGHOME'] = GNUPGHOME
        self.check_gnupghome(GNUPGHOME)

        try:
            text = sh.gpg('--with-colons', '--fingerprint', key_data['key'], _env=env).strip()
        except sh.ErrorReturnCode, err:
            return False

        for fingerprint in text.split('\n'):
            if fingerprint.startswith(u'fpr:') and fingerprint == key_data['verify']:
                verified = True
                break

        if not verified:
            print sh.gpg('--fingerprint', key_data['key'], _env=env)
            return False

        return verified

    def verify_keys(self, keys, message=None, force=False):
        env = os.environ.copy()
        env['GNUPGHOME'] = GNUPGHOME
        self.check_gnupghome(GNUPGHOME)

        for id, key_data in keys.items():
            key = key_data['key']
            is_key_missing = True
            try:
                text = sh.gpg('--list-key', key, _env=env)
                is_key_missing = text.exit_code
            except sh.ErrorReturnCode, err:
                # exit_code will be non-zero and will trigger installation and verification of keys
                pass

            if force or is_key_missing:
                info = {
                    'title':  'Add Key {0}'.format(id),
                    'default_button': 'no',
                }
                if message:
                    info['text'] = u'Owner: {key_data[owner]}\n\n{0}\n\nSelect "Yes" to add or "No" to exit'.format(message, key_data=key_data)
                elif force:
                    info['text'] = u'Owner: {key_data[owner]} forced get.\n\nSelect "Yes" to re-add or "No" to exit'.format(key_data=key_data)
                else:
                    info['text'] = u'Owner: {key_data[owner]} key does not exist.\n\nSelect "Yes" to add or "No" to exit'.format(key_data=key_data)

                if not self.ui.verify_keys(**info):
                    exit('User aborted setup: Exiting setup since keys can not be installed')

                # Receive key from keyserver
                else:
                    try:
                        cmd = 'GNUPGHOME={0} gpg --keyserver {1} --recv-keys {2}'.format(GNUPGHOME, GPG_KEY_SERVER, key)
                        text = sh.gpg('--keyserver', GPG_KEY_SERVER, '--recv-keys', key, _env=env)
                        sh.gpg(sh.echo('{0}:6:'.format(key)), '--import-ownertrust', _env=env)
                    except sh.ErrorReturnCode, err:
                        print err.message
                        exit(err.message)

            # Verify key on every run
            result = self.gpg_verify_key(key_data)
            if not result:
                exit({'title': '{key_data[owner]} fingerprint failed!'.format(key_data=key_data),
                      'text': '\nWrong fingerprint\n{key[fingerprint]}\n\nExiting!'.format(key_data=key_data),})

        # Add developers keys
        try:
            sh.gpg('--import', QUBES_DEVELOPERS_KEYS, _env=env)
        except sh.ErrorReturnCode, err:
            exit('Unable to import Qubes developer keys: {0}. Please install them manually.\n{1}'.format(QUBES_DEVELOPERS_KEYS, err))

        return True

    def set_release(self, force=False):
        '''Select release version of Qubes to build.
        '''
        try:
            release = sh.make('-C', self.dir_builder, '-B', 'release', '--quiet').strip()
        except sh.ErrorReturnCode, err:
            exit(err)

        default_button = 'yes' if release == '2' else 'no'
        info = {
            'title':  'Choose Qubes Version',
            'yes_label': 'Release 2',
            'no_label': 'Release 3',
            'default_button': default_button,
            'text': dedent('''\
                Choose which version of Qubes you wish to build.

                Valid options are either the stable release 2 or development release 3 version.
            '''),
        }

        result = self.ui.release(**info)
        self.release = '2' if result else '3'

    def set_repo(self):
        '''Set repo prefix.
        '''
        choices = []
        default_set = False
        full_prefix = '{0}/{1}'.format(self.git_baseurl, self.git_prefix)

        for index, repo in self.repos.items():
            toggle = full_prefix.endswith(repo['prefix'])
            if toggle:
                default_set = True
            choices.append( (repo['prefix'], repo['description'], toggle) )

        choices.insert(0, (self.git_prefix_default, 'Stable - Default Repo', not default_set) )

        info = {
            'title':  'Choose Repos To Use To Build Packages',
            'choices': choices,
            'width': 76,
            'height': 16,
        }

        self.git_prefix = self.ui.repo(**info)

    def set_ssh_access(self):
        '''Set GIT_BASEURL and GIT_PREFIX to allow ssh (write) access to repo.
         Convert:
           `GIT_BASEURL` from `git://github.com` to `git@github.com:repo`
         - and -
           `GIT_PREFIX` from `repo/qubes-` to `qubes-`
        '''
        default_button = 'yes' if self.ssh_access else 'no'
        info = {
            'title':  'Enable SSH Access',
            'default_button': default_button,
            'text': dedent('''\
                Do you have ssh access to the repos?

                Select 'Yes' to configure urls to match git or 'No' for https"
            '''),
        }
        result = self.ui.ssh_access(**info)
        ssh_access = 1 if result else 0

        if ssh_access:
            if '/' in self.git_prefix:
                repo, prefix = self.git_prefix.split('/')
                self.git_prefix = prefix
            else:
                repo = self.git_baseurl.split(':')[-1]
                prefix = self.git_prefix

        # Re-write baseurl depending on ssh_access mode
        baseurl = re.match(r'^(.*//|.*@)(.*(?=[:])|.*)([:].*|)', self.git_baseurl)
        if ssh_access:
            self.git_baseurl = 'git@{0}:{1}'.format(baseurl.group(2), repo)
        else:
            self.git_baseurl = 'https://{0}'.format(baseurl.group(2))

        self.ssh_access = ssh_access

    def set_template_only(self):
        '''Choose to build a complete system or templates only.
        '''
        default_button = 'yes' if self.template_only else 'no'
        info = {
            'title':  'Build Template Only?',
            'default_button': default_button,
            'text': dedent('''\
                Would you like to build only the templates?

                Select 'Yes' to to only build templates or 'No' for complete build
            '''),
        }
        self.template_only = self.ui.template_only(**info)

    def set_dists(self):
        ''''''
        choices = []
        helper = {}
        for dist in self.dists_vm_all:
            alias = self.template_aliases.get(dist, '')
            aliasr = self.template_aliases_reversed.get(dist, '')
            label = self.template_labels.get(alias or dist, '')

            tag = aliasr or dist
            item = label
            help = dist if dist != tag else ''

            helper[tag] = dedent('''\
                \Zb\Z4Distribution:\Zn {0}
                \Zb\Z4Template Label:\Zn {1}
                \Zb\Z4Template Alias:\Zn {2}
            ''').format(tag, item, help)

            if help:
                help = 'Alias value: {0}'.format(help)

            choices.append( (tag, item, dist in self.dists_vm_selected, help) )

        info = {
            'helper': helper,
            'height': 0,
            'width': 0,
            'list_height': 0,
            'choices': choices,
            'title': 'Template Distribution Selection',
            'help_button': True,
            'item_help': True,
            'help_tags': True,
            'help_status': True,
            'text': dedent('''\
                \Zb\Z4Left column contains DIST name\Zn
                \Zb\Z4Right column contains TEMPLATE_LABEL\Zn
            '''),
        }

        self.dists_vm_selected = self.ui.dists(**info)

    def get_sources(self):
        '''Prompt user to get sources.
        '''
        default_button = 'yes'
        info = {
            'title':  'Get sources',
            'default_button': 'yes',
            'height': 0,
            'width': 0,
            'text': dedent('''\
                Either a BUILDER_PLUGIN has been added or Qubes sources have not
                yet been downloaded.

                Would you like to get Qubes source files now? If you choose no you
                may need to run set again after getting sources manually to be able
                to select some VMs for building.

                Select 'Yes' to download and merge sources or 'No' to skip"
            '''),
        }
        retcode = self.ui.get_sources(**info)


    def set_builders(self):
        ''''''
        # Build required depends list
        def _depends(builder, key):
            depends = []
            if not builder.get(key, None):
                return depends
            items = builder[key]
            # Filter builder depends to only dists_vm_selected
            for item in items:  # dist in dists from require_in
                for dist in self.dists_vm_selected:
                    alias = self.template_aliases.get(dist, dist)
                    if item in alias:
                        if dist not in depends:
                            depends.append(dist)
            return depends

        def _missing():
            missing = {}
            for builder in self.builders.values():
                # Check to see if a disabled builder has dist vms selected and warn
                if builder['id'] not in self.builders_selected:
                    for dist in self.dists_vm_selected:
                        alias = self.template_aliases.get(dist, dist)
                        for item in builder['require_in']:
                            if item in alias:
                                missing.setdefault(builder['id'], [])
                                if dist not in missing[builder['id']]:
                                    missing[builder['id']].append(dist)
            return missing

        def _requires():
            requires = {}
            for builder_name in self.builders_selected:
                builder = self.builders.get(builder_name, {})
                for plugin in builder.get('require', []):
                    if plugin not in self.builders_selected:
                        requires.setdefault(builder_name, [])
                        requires[builder_name].append(plugin)
            return requires

        def _requires_key():
            for builder_name in self.builders_selected:
                builder = self.builders.get(builder_name, {})
                if builder.get('key', False):
                    # Setup will exit if user chooses not to install key
                    message = 'The BUILDER_PLUGIN {0} requires a third party key.'.format(builder['id'])
                    key_id = '0x{0}'.format(builder['key'][-8:])
                    self.verify_keys({key_id: builder}, message=message)
            return True

        def _colorize(items, missing):
            colorized = []
            for item in items:
                if item in missing:
                    colorized.append('\Z1{0}\Zn'.format(item))
                else:
                    colorized.append('\Z2{0}\Zn'.format(item))
            return colorized

        while True:
            choices = []
            helper = {}
            missing = _missing()
            requires = _requires()

            for builder in self.builders.values():
                # Skip development plugins if development mode was not enabled (--development)
                if builder.get('development', None) and not self.cli_args.get('development', None):
                    continue

                tag = builder['id']
                help = builder['description']

                helper_text = dedent('''\
                    \Zb\Z4Builder Plugin:\Zn {0}
                    \Zb\Z4Description:\Zn {1}
                ''').format(tag, help)

                require = []
                for builder_name in builder['require']:
                    if builder_name in self.builders_selected:
                        require.append('\Z2{0}\Zn'.format(builder_name))
                    else:
                        require.append('\Z1{0}\Zn'.format(builder_name))

                if require:
                    helper_text += '\Zb\Z4This plugin requires: {0}\n'.format(' '.join(require))
                    require = 'Requires: {0}'.format(' '.join(require))
                else:
                    helper_text += '\Zb\Z4This plugin requires:\Zn None\n'

                require_in = _colorize(_depends(builder, 'require_in'), missing.get(tag, [])) or None
                if require_in:
                    helper_text += '\Zb\Z4This plugin is needed by:\Zn {0}\n'.format(' '.join(require_in))
                    require_in = 'For: {0}'.format(' '.join(require_in))
                else:
                    helper_text += '\Zb\Z4This plugin is needed by:\Zn None\n'

                optional = _depends(builder, 'optional') or None
                if optional:
                    helper_text += '\Zb\Z4Optional plugin for:\Zn {0}\n'.format(' '.join(optional))
                    optional = 'For: {0}'.format(' '.join(optional))

                item = require or require_in or optional or ''
                helper[tag] = helper_text
                choices.append( (tag, item, builder['id'] in self.builders_selected, help) )

            info = {
                'helper': helper,
                'height': 0,
                'width': 0,
                'list_height': 0,
                'choices': choices,
                'title': 'Builder Plugins Selection',
                'help_button': True,
                'item_help': True,
                'help_tags': True,
                'help_status': True,
                'text': dedent('''\
                    Select from the following list any builder plugins to be enabled.

                    Note that some plugins are required to build specific VM's as will
                    be indicated by the comment to the left of the plugin choice.
                '''),
            }

            builders_selected = self.builders_selected
            self.builders_selected = self.ui.builders(**info)

            # Selected builders changed; write and reload config file to reflect
            # changes
            if builders_selected !=  self.builders_selected:
                # Check if BUILDER_PLUGIN requires a key to install; prompt to install
                # Setup will exit if user chooses not to install key
                _requires_key()

                self.write_configuration()
                self._parse_makefiles()

                # Download sources
                # TODO: determine if BUILDER_PLUGIN has previously been downloaded
                self.get_sources()
                self._parse_makefiles()

            missing = _missing()
            requires = _requires()
            if requires:
                text = ''
                for builder_name, missing_builder in requires.items():
                    text += '\Z1{0}\Zn is selected to be installed but\n'.format(builder_name)
                    text += '\Z4{0}\Zn is not enabled! Either enable \Z4{0}\Zn or disable \Z1{1}\Zn.\n\n'.format(' '.join(missing_builder), builder_name)
                self.ui.msgbox(text)
            elif missing:
                text = ''
                for builder_name, missing_vms in missing.items():
                    text += '\Z1{0}\Zn are selected to be installed but\n'.format(' '.join(missing_vms))
                    text += '\Z4{0}\Zn is not enabled! Either enable \Z4{0}\Zn or exit to re-pick VMs.\n\n'.format(builder_name)
                self.ui.msgbox(text)
            else:
                break


class ReplaceInplace(object):
    def __init__(self, filename):
        self.filename = filename
        self.rules = {}

    defaults =  {
        # key to use to match line
        'match_key': None,

        # text will be inserted below pattern matched line. Keeps pattern.
        'insert_after': None,

        # all text before this line will be removed.  Keeps pattern
        # if value is `None`, stop insert mode after initial insert
        'insert_until': None,

        'replace': None,

        'text': None,
        'find': None,
        'start_line': None,
        'stop_line': None,
    }

    def add(self, **kwargs):
        default = copy.deepcopy(self.defaults)
        default.update(kwargs)

        if default['insert_after']:
            default['insert_after'] = re.compile(r'{0}'.format(default['insert_after']))
            default['match_key'] = 'insert_after'

            if default['insert_until']:
                default['insert_until'] = re.compile(r'{0}'.format(default['insert_until']))

        elif default['replace']:
            default['replace'] = re.compile(r'{0}'.format(default['replace']))
            default['match_key'] = 'replace'

        match_key = default[default['match_key']]
        self.rules[match_key] = default

    def start(self):
        import fileinput
        insert_mode = False
        stop = []

        for line in fileinput.input(self.filename, inplace=True, backup=BACKUP_EXTENSION):
            line =  line.rstrip('\n')
            for rule in self.rules:
                if rule.search(line):
                    if self.rules[rule]['match_key'] == 'insert_after':
                        insert_mode = True
                        stop.append(self.rules[rule]['insert_until'])
                        print line
                        print self.rules[rule]['text']
                    elif self.rules[rule]['match_key'] == 'replace':
                        line = rule.sub(self.rules[rule]['text'], line)

            for rule in stop:
                if re.match(rule, line):
                    stop.remove(rule)
                    insert_mode = False

            if not insert_mode:
                print line


def set_default_subparser(self, name, args=None):
    """Default Subparser Selection.

    Call after setup, just before parse_args()
    name: is the name of the subparser to call by default
    args: if set is the argument list handed to parse_args()

    Tested with 2.7, 3.2, 3.3, 3.4
    it works with 2.6 assuming argparse is installed

    http://stackoverflow.com/questions/6365601/default-sub-command-or-handling-no-sub-command-with-argparse
    """
    subparser_found = False
    for arg in sys.argv[1:]:
        if arg in ['-h', '--help']:  # global help if no subparser
            break
    else:
        for x in self._subparsers._actions:
            if not isinstance(x, argparse._SubParsersAction):
                continue
            for sp_name in x._name_parser_map.keys():
                if sp_name in sys.argv[1:]:
                    subparser_found = True
        if not subparser_found:
            # insert default in first position, this implies no
            # global options without a sub_parsers specified
            if args is None:
                sys.argv.insert(1, name)
            else:
                args.insert(0, name)

argparse.ArgumentParser.set_default_subparser = set_default_subparser

def main(argv):
    parser = argparse.ArgumentParser()
    mode = parser.add_subparsers(dest='mode', help='commands')

    wizard = mode.add_parser('wizard', help='Runs setup wizard')
    wizard.add_argument( '--dialog-release', action='store', default='3', help='Display the Choose Release Dialog' )
    wizard.add_argument( '--dir', dest='dir_builder', action='store', default=None,
                         help='Location path of qubes-builder base directory' )
    wizard.add_argument( '-c', dest='config_filename', action='store', default='.setup.data',
                         help='Setup configuration file' )
    wizard.add_argument( '--development', action='store_true', default=DEVELOPMENT_MODE,
                         help='include in-progress development configuration options' )

    info = mode.add_parser('info', help='Display builder configuration')
    info.add_argument( '-c', dest='config_filename', action='store', default=BUILDER_CONF,
                       help='configuration file ({0})'.format(BUILDER_CONF) )

    depends = mode.add_parser('install-deps', help='Install build dependencies')

    parser.set_default_subparser('wizard')
    args = vars(parser.parse_args())
    mode = args['mode']

    if mode == 'wizard':
        Wizard(DialogUI(), **args)()
    elif mode == 'info':
        display_configuration(args['config_filename'])
    elif mode == 'install-deps':
        install_deps()


try:
    import sh
except ImportError:
    install_deps('python-sh')
    import sh


if __name__ == '__main__':
    # If no builder.conf is present; assume install-deps has not been run
    if not os.path.exists(BUILDER_CONF):
        install_deps('qubes-builder dependencies')

    main(sys.argv)
    sys.exit(0)
